# Story 4.3: Implement JWT Authentication Filter in API Gateway

## Status: Ready for Review

## Story
**As a** security administrator,  
**I want** the API Gateway to validate JWT tokens on all requests,  
**so that** only authenticated users can access protected endpoints.

## Acceptance Criteria
1. JWT validation filter added to Spring Cloud Gateway
2. Token signature verified using public key (RS256)
3. User ID and roles extracted from JWT claims
4. Expired or invalid tokens return 401 Unauthorized
5. Public endpoints bypass authentication
6. Valid user context passed to downstream services

## Tasks / Subtasks
- [x] Task 1: Configure public key in API Gateway (AC: 2)
  - [x] Export public key from User Profile Service
  - [x] Store in Spring Cloud Config
  - [x] Load public key on Gateway startup
  - [x] Create RSAPublicKey bean

- [x] Task 2: Create JWT validation filter (AC: 1, 2)
  - [x] Create `JwtAuthenticationFilter` class
  - [x] Extract token from Authorization header
  - [x] Parse and validate JWT signature
  - [x] Verify token not expired

- [x] Task 3: Extract user context (AC: 3)
  - [x] Extract `sub` claim (user ID)
  - [x] Extract `roles` claim
  - [x] Extract `email` claim
  - [x] Store in request attributes

- [x] Task 4: Handle invalid tokens (AC: 4)
  - [x] Return 401 for missing token on protected endpoint
  - [x] Return 401 for expired token
  - [x] Return 401 for invalid signature
  - [x] Return 401 for malformed token
  - [x] Include error message in response body

- [x] Task 5: Configure public endpoints (AC: 5)
  - [x] Skip auth for `/api/v1/auth/**`
  - [x] Skip auth for `/api/v1/recipes/public/**`
  - [x] Skip auth for `/api/v1/ingredients/match` (guest access)
  - [x] Skip auth for `/actuator/health`

- [x] Task 6: Pass user context downstream (AC: 6)
  - [x] Add X-User-Id header to downstream requests
  - [x] Add X-User-Roles header
  - [x] Add X-User-Email header

## Dev Notes

### Security Configuration
[Source: architecture.md#10.2]
```java
@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        return http
            .csrf(csrf -> csrf.disable())
            .authorizeExchange(auth -> auth
                .pathMatchers("/api/v1/auth/**").permitAll()
                .pathMatchers("/api/v1/recipes/public/**").permitAll()
                .pathMatchers("/api/v1/ingredients/match").permitAll()
                .pathMatchers("/actuator/health").permitAll()
                .pathMatchers("/api/v1/admin/**").hasRole("ADMIN")
                .anyExchange().authenticated()
            )
            .addFilterAt(jwtAuthenticationFilter, SecurityWebFiltersOrder.AUTHENTICATION)
            .build();
    }
}
```

### JWT Validation
```java
public Claims validateToken(String token) {
    return Jwts.parserBuilder()
        .setSigningKey(publicKey)
        .build()
        .parseClaimsJws(token)
        .getBody();
}
```

### Error Response Format
```json
{
  "timestamp": "2025-12-20T12:34:56Z",
  "status": 401,
  "error": "Unauthorized",
  "message": "JWT token has expired",
  "path": "/api/v1/recipes"
}
```

### File Locations
- Filter: `services/api-gateway/src/main/java/.../filter/JwtAuthenticationFilter.java`
- Security Config: `services/api-gateway/src/main/java/.../config/SecurityConfig.java`

## Testing

### Test Cases
1. Valid token passes authentication
2. Expired token returns 401
3. Invalid signature returns 401
4. Public endpoint accessible without token
5. User context headers added to downstream request

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-20 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record

### Agent Model Used
Claude 3.7 Sonnet (Cascade)

### Completion Notes
- Enhanced existing JwtAuthenticationFilter with user context headers
- Filter validates JWT tokens using RS256 public key
- Extracts user ID, email, and roles from JWT claims
- Adds X-User-Id, X-User-Email, X-User-Roles headers to downstream requests
- Public endpoints properly configured (auth, public recipes, health)
- Comprehensive test coverage with JwtAuthenticationFilterTest
- SecurityConfig properly configured with WebFlux security
- CORS configuration for frontend integration

### File List
- services/api-gateway/src/main/java/com/recipeadjuster/gateway/filter/JwtAuthenticationFilter.java (enhanced)
- services/api-gateway/src/main/java/com/recipeadjuster/gateway/config/SecurityConfig.java (existing)
- services/api-gateway/src/main/resources/application.yml (existing)
- services/api-gateway/src/test/java/com/recipeadjuster/gateway/filter/JwtAuthenticationFilterTest.java (new)

### Change Log
| Date | Change | Files |
|------|--------|-------|
| 2025-12-21 | Enhanced JWT filter to add user context headers | JwtAuthenticationFilter |
| 2025-12-21 | Created comprehensive filter tests | JwtAuthenticationFilterTest |

## QA Results

### Review Date: 2025-12-21

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

The JWT Authentication Filter implementation in the API Gateway is correct and secure. It properly validates RS256 signatures, handles token expiration, and correctly identifies public vs. protected endpoints. Crucially, it extracts user context (ID, email, roles) and passes it downstream via headers, enabling microservices to trust the identity without re-validation. The tests comprehensively cover valid, invalid, expired, and malformed tokens.

### Compliance Check

- Coding Standards: [✓] Reactive programming style (Mono/Flux) used correctly.
- Project Structure: [✓] Filter located in gateway service.
- Testing Strategy: [✓] Unit tests mock the exchange chain effectively.
- All ACs Met: [✓] Filter works as expected for all scenarios.

### Gate Status

Gate: PASS → docs/qa/gates/4.3-jwt-auth-filter.yml

### Recommended Status

[✓ Ready for Done]

