# Frontend Test Strategy: Stories 5.3–5.9

**Generated by:** Quinn (Test Architect)  
**Date:** 2025-12-21  
**Scope:** Angular 20 frontend implementation (Epic 5)

---

## Executive Summary

This document provides a comprehensive test strategy for the Angular frontend stories 5.3–5.9, focusing on the highest-risk areas identified during QA review. The strategy covers unit, integration, and E2E testing with specific test cases mapped to acceptance criteria.

### Risk Profile

**High Risk Areas:**
- NgRx state management flows (5.3)
- Recipe search/detail navigation (5.4)
- Offline/IndexedDB implementation (5.7)
- Service worker caching (5.8)
- Performance metrics (5.9)

**Medium Risk Areas:**
- Substitution panel UX (5.5)
- Form validation edge cases (5.3)

---

## Story 5.3: Ingredient Input Feature

### Unit Tests (Priority: P0)

#### Reducer Tests
```typescript
describe('IngredientReducer', () => {
  it('should add ingredient to state', () => {
    // Given: empty state
    // When: addIngredient action dispatched
    // Then: ingredient appears in state array
  });

  it('should remove ingredient from state', () => {
    // Given: state with 3 ingredients
    // When: removeIngredient action with middle ingredient
    // Then: ingredient removed, order preserved
  });

  it('should update suggestions on loadSuggestionsSuccess', () => {
    // Given: state with empty suggestions
    // When: loadSuggestionsSuccess with 5 suggestions
    // Then: suggestions array populated
  });

  it('should set loading flag during suggestion fetch', () => {
    // Given: initial state
    // When: loadSuggestions action
    // Then: loading = true
  });
});
```

#### Selector Tests
```typescript
describe('IngredientSelectors', () => {
  it('should select ingredients array', () => {
    // Given: state with 3 ingredients
    // When: selectIngredients called
    // Then: returns correct array
  });

  it('should select loading state', () => {
    // Given: state with loading = true
    // When: selectLoading called
    // Then: returns true
  });
});
```

#### Effects Tests
```typescript
describe('IngredientEffects', () => {
  it('should debounce suggestion requests', fakeAsync(() => {
    // Given: rapid input changes
    // When: loadSuggestions dispatched 5 times in 200ms
    // Then: only 1 API call made after debounce
  }));

  it('should save to localStorage on ingredient change', () => {
    // Given: saveToStorage action
    // When: effect runs
    // Then: localStorage.setItem called with correct data
  });

  it('should load from localStorage on init', () => {
    // Given: localStorage has saved ingredients
    // When: loadFromStorage action
    // Then: loadFromStorageSuccess dispatched with data
  });
});
```

### Component Tests (Priority: P1)

```typescript
describe('IngredientInputComponent', () => {
  it('should add ingredient on Enter key', () => {
    // Given: input with "tomato"
    // When: Enter pressed
    // Then: addIngredient action dispatched
  });

  it('should show validation error when empty', () => {
    // Given: no ingredients
    // When: component renders
    // Then: "Add at least 1 ingredient" displayed
  });

  it('should disable search button when > 20 ingredients', () => {
    // Given: 21 ingredients in state
    // When: component renders
    // Then: Find Recipes button disabled
  });

  it('should remove ingredient on chip remove', () => {
    // Given: 3 ingredients displayed
    // When: remove button clicked on 2nd chip
    // Then: removeIngredient action dispatched
  });
});
```

### Integration Tests (Priority: P1)

```typescript
describe('Ingredient Input Integration', () => {
  it('should complete full ingredient flow', () => {
    // Given: app loaded
    // When: user adds 3 ingredients, clicks Find Recipes
    // Then: navigates to /search with ingredients in state
  });

  it('should persist ingredients across page refresh', () => {
    // Given: 3 ingredients added
    // When: page refreshed
    // Then: ingredients restored from storage
  });
});
```

---

## Story 5.4: Recipe Results & Detail Views

### Component Tests (Priority: P0)

```typescript
describe('RecipeCardComponent', () => {
  it('should display match percentage with correct color', () => {
    // Given: recipe with 95% match
    // When: component renders
    // Then: green color class applied
  });

  it('should emit cardClick on click', () => {
    // Given: recipe card rendered
    // When: card clicked
    // Then: cardClick event emitted with recipe ID
  });

  it('should show missing ingredients count', () => {
    // Given: recipe with 3 missing ingredients
    // When: component renders
    // Then: "3 missing" displayed
  });
});

describe('RecipeSearchComponent', () => {
  it('should display recipe grid', () => {
    // Given: 6 recipes in state
    // When: component renders
    // Then: 6 recipe cards displayed
  });

  it('should show loading spinner during fetch', () => {
    // Given: loading = true
    // When: component renders
    // Then: loading spinner visible
  });

  it('should navigate to detail on card click', () => {
    // Given: recipe card rendered
    // When: card clicked
    // Then: router navigates to /recipes/:id
  });
});

describe('RecipeDetailComponent', () => {
  it('should display all recipe sections', () => {
    // Given: recipe loaded
    // When: component renders
    // Then: ingredients, instructions, nutrition all visible
  });

  it('should show substitution button when ingredients missing', () => {
    // Given: recipe with 2 missing ingredients
    // When: component renders
    // Then: "Show Substitutions (2 missing)" button visible
  });

  it('should mark unavailable ingredients', () => {
    // Given: recipe with 2 unavailable ingredients
    // When: component renders
    // Then: unavailable class applied to those items
  });
});
```

### E2E Tests (Priority: P0)

```typescript
describe('Recipe Search Flow', () => {
  it('should complete full search-to-detail flow', async () => {
    // Given: user on home page
    // When: adds ingredients, clicks Find Recipes
    // Then: navigates to search results
    // When: clicks first recipe card
    // Then: navigates to recipe detail
    // And: all recipe info displayed
  });

  it('should handle empty search results', async () => {
    // Given: search with no results
    // When: search completes
    // Then: "No recipes found" message displayed
  });
});
```

---

## Story 5.5: Substitution Panel

### Component Tests (Priority: P1)

```typescript
describe('SubstitutionPanelComponent', () => {
  it('should open panel when opened input is true', () => {
    // Given: opened = false
    // When: opened set to true
    // Then: panel slides in from right
  });

  it('should emit closed event on close button', () => {
    // Given: panel open
    // When: close button clicked
    // Then: closed event emitted
  });

  it('should emit substitution selection', () => {
    // Given: panel with substitutions
    // When: "Use This Substitution" clicked
    // Then: substitutionSelected event emitted with correct data
  });

  it('should display all substitutes for ingredient', () => {
    // Given: ingredient with 3 substitutes
    // When: panel renders
    // Then: 3 substitute cards displayed
  });
});
```

---

## Story 5.7: Offline / IndexedDB

### Unit Tests (Priority: P0)

```typescript
describe('OfflineStorageService', () => {
  it('should save recipe to IndexedDB', async () => {
    // Given: recipe object
    // When: cacheRecipe called
    // Then: recipe stored in DB
  });

  it('should retrieve cached recipes', async () => {
    // Given: 3 recipes in cache
    // When: getCachedRecipes called
    // Then: returns all 3 recipes
  });

  it('should handle storage quota exceeded', async () => {
    // Given: DB near quota limit
    // When: cacheRecipe called with large recipe
    // Then: error handled gracefully, oldest entries evicted
  });
});
```

### Integration Tests (Priority: P0)

```typescript
describe('Offline Functionality', () => {
  it('should display cached recipes when offline', async () => {
    // Given: 3 recipes viewed and cached
    // When: network set to offline
    // And: user navigates to recipe detail
    // Then: recipe loaded from cache
  });

  it('should queue operations when offline', async () => {
    // Given: offline mode
    // When: user adds ingredient
    // Then: operation queued in pendingSync table
  });

  it('should sync pending operations on reconnect', async () => {
    // Given: 2 operations in pendingSync
    // When: network reconnects
    // Then: operations synced to server
    // And: pendingSync table cleared
  });
});
```

### E2E Tests (Priority: P0)

```typescript
describe('Offline Mode E2E', () => {
  it('should work fully offline after initial load', async () => {
    // Given: app loaded, 5 recipes cached
    // When: DevTools offline mode enabled
    // Then: user can view cached recipes
    // And: user can add ingredients (stored locally)
    // And: offline indicator displayed
  });
});
```

---

## Story 5.8: Service Worker / PWA

### Integration Tests (Priority: P0)

```typescript
describe('Service Worker Caching', () => {
  it('should cache recipe API responses', async () => {
    // Given: SW registered
    // When: recipe API called
    // Then: response cached per ngsw-config
  });

  it('should serve from cache when offline', async () => {
    // Given: recipe cached
    // When: offline mode, recipe requested
    // Then: served from cache
  });

  it('should update cache on new version', async () => {
    // Given: old version cached
    // When: new SW version available
    // Then: update notification shown
    // When: user accepts update
    // Then: page reloads with new version
  });
});
```

### E2E Tests (Priority: P1)

```typescript
describe('PWA Install Flow', () => {
  it('should show install prompt on mobile', async () => {
    // Given: PWA installable
    // When: user visits site 2nd time
    // Then: install prompt displayed
  });

  it('should install as PWA', async () => {
    // Given: install prompt shown
    // When: user clicks Install
    // Then: app added to home screen
  });
});
```

### Manual Tests (Priority: P0)

1. **Lighthouse PWA Audit**
   - Run Lighthouse in Chrome DevTools
   - Target: PWA score > 90
   - Verify: manifest, SW, offline, installable

2. **Mobile Install Test**
   - Test on iOS Safari and Android Chrome
   - Verify install prompt appears
   - Verify app works offline after install

---

## Story 5.9: Performance Optimization

### Performance Tests (Priority: P0)

```typescript
describe('Bundle Size', () => {
  it('should keep initial bundle under 500kB', () => {
    // Given: production build
    // When: bundle analyzed
    // Then: main bundle < 500kB gzipped
  });

  it('should lazy load feature modules', () => {
    // Given: app loaded
    // When: initial page load
    // Then: only core + home bundles loaded
    // When: navigate to /search
    // Then: search bundle loaded on demand
  });
});
```

### E2E Performance Tests (Priority: P0)

```typescript
describe('Performance Metrics', () => {
  it('should meet FCP target', async () => {
    // Given: app deployed
    // When: Lighthouse run
    // Then: First Contentful Paint < 1.5s
  });

  it('should meet TTI target', async () => {
    // Given: app deployed
    // When: Lighthouse run
    // Then: Time to Interactive < 3s
  });

  it('should handle large recipe lists efficiently', async () => {
    // Given: 100 recipes in results
    // When: user scrolls
    // Then: virtual scroll renders only visible items
    // And: scroll remains smooth (60fps)
  });
});
```

### Manual Tests (Priority: P0)

1. **Lighthouse Audit**
   - Performance score > 85
   - PWA score > 90
   - Accessibility score > 90
   - Best Practices score > 90

2. **Bundle Analysis**
   - Run `webpack-bundle-analyzer`
   - Identify largest dependencies
   - Verify tree-shaking working

3. **Network Throttling**
   - Test on Fast 3G
   - Verify acceptable load times
   - Verify progressive loading

---

## Test Execution Priority

### Phase 1: Critical Path (Week 1)
- [ ] 5.3 NgRx unit tests (reducer, selectors, effects)
- [ ] 5.4 Recipe navigation E2E test
- [ ] 5.7 Offline storage unit tests
- [ ] 5.9 Lighthouse baseline audit

### Phase 2: Integration (Week 2)
- [ ] 5.3 Component tests
- [ ] 5.4 Recipe card/search/detail component tests
- [ ] 5.7 Offline integration tests
- [ ] 5.8 SW caching tests

### Phase 3: Polish (Week 3)
- [ ] 5.5 Substitution panel tests
- [ ] 5.8 PWA install flow tests
- [ ] 5.9 Performance regression suite
- [ ] Cross-browser testing

---

## Test Infrastructure Recommendations

### Tools
- **Unit/Component:** Jest + Angular Testing Library
- **E2E:** Playwright (already in coding standards)
- **Performance:** Lighthouse CI
- **Bundle Analysis:** webpack-bundle-analyzer

### CI Integration
```yaml
# .github/workflows/frontend-tests.yml
name: Frontend Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install dependencies
        run: cd frontend && npm ci
      - name: Run unit tests
        run: cd frontend && npm run test:ci
      - name: Run E2E tests
        run: cd frontend && npm run e2e:ci
      - name: Run Lighthouse
        run: cd frontend && npm run lighthouse:ci
```

---

## Coverage Targets

- **Unit Tests:** > 80% line coverage for NgRx store files
- **Component Tests:** > 70% coverage for feature components
- **E2E Tests:** All critical user flows covered
- **Performance:** All Lighthouse scores > 85

---

## Next Steps

1. Set up Jest + Angular Testing Library configuration
2. Create test fixtures and mock data
3. Implement Phase 1 critical tests
4. Set up Playwright for E2E
5. Configure Lighthouse CI
6. Add tests to CI pipeline

---

**Document Status:** Ready for Implementation  
**Estimated Effort:** 3 weeks (1 developer)  
**Dependencies:** None (can start immediately)
